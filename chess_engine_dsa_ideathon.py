# -*- coding: utf-8 -*-
"""Chess Engine_DSA Ideathon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xnMJ3rsb9PUfYolln9gxtDneVz_BpMna
"""

!pip install python-chess

import chess
import chess.svg
from IPython.display import SVG, display

board = chess.Board()
svg_board = chess.svg.board(board=board, size=400)
display(SVG(svg_board))

import chess
board = chess.Board()

def evaluate_board(board):
    piece_values = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1}
    white_score = sum(piece_values.get(piece.symbol(), 0) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)
    black_score = sum(piece_values.get(piece.symbol(), 0) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)
    return white_score - black_score

def generate_moves(board, depth):
    if depth == 0 or board.is_game_over():
        return []
    moves = []
    for move in board.legal_moves:
        board.push(move)
        eval_score = evaluate_board(board)
        moves.append((move, eval_score, generate_moves(board, depth - 1)))
        board.pop()
    return moves

legal_moves = list(board.legal_moves)
print(legal_moves)

tree = generate_moves(board, depth=5)

def minimax(board, depth, maximizing_player=True):
    if depth == 0 or board.is_game_over():
        return evaluate_board(board)

    legal_moves = list(board.legal_moves)
    if maximizing_player:
        max_eval = float('-inf')
        for move in legal_moves:
            board.push(move)
            eval_score = minimax(board, depth - 1, False)
            max_eval = max(max_eval, eval_score)
            board.pop()
        return max_eval
    else:
        min_eval = float('inf')
        for move in legal_moves:
            board.push(move)
            eval_score = minimax(board, depth - 1, True)
            min_eval = min(min_eval, eval_score)
            board.pop()
        return min_eval

def play_move(board, depth):
    legal_moves = list(board.legal_moves)
    if not legal_moves:
        return None

    best_move = None
    best_eval = float('-inf')
    for move in legal_moves:
        board.push(move)
        eval_score = minimax(board, depth - 1, False)
        board.pop()
        if eval_score > best_eval:
            best_eval = eval_score
            best_move = move

    return best_move

best_move = play_move(board, depth=5)
if best_move:
    board.push(best_move)
    print(board)
else:
    print("No legal moves available.")

board

import chess

def evaluate_board(board):
    piece_values = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1}
    white_score = sum(piece_values.get(piece.symbol(), 0) for square, piece in board.piece_map().items() if piece.color == chess.WHITE)
    black_score = sum(piece_values.get(piece.symbol(), 0) for square, piece in board.piece_map().items() if piece.color == chess.BLACK)
    return white_score - black_score

def generate_moves(board, depth):
    if depth == 0 or board.is_game_over():
        return []
    moves = []
    for move in board.legal_moves:
        board.push(move)
        eval_score = evaluate_board(board)
        moves.append((move, eval_score, generate_moves(board, depth - 1)))
        board.pop()
    return moves

board = chess.Board()

num_moves = 5

for _ in range(num_moves):
    tree = generate_moves(board, depth=5)
    best_move = max(tree, key=lambda x: x[1])[0]
    board.push(best_move)

    print(board)
    print("---")
    board

board